## Creational Design Patterns

<!--å†™äº2021å¹´-->

å…³äºå®ä¾‹åŒ–ä¸€ä¸ªå¯¹è±¡ï¼Œæˆ–è€…ä¸€ç»„ç›¸å…³å¯¹è±¡

<Br/>

### Simple Factory

è§£é‡Šï¼šSimple factoryå°±æ˜¯ç»™ä½¿ç”¨è€…ï¼Œç”Ÿæˆä¸€ä¸ªå¯¹è±¡ï¼Œè€Œæ²¡æœ‰æš´éœ²ç”Ÿæˆå¯¹è±¡çš„é€»è¾‘ç»†èŠ‚

> Simple factory simply generates an instance for client without exposing any instantiation logic to the client.

<Br/>

JavaScriptä»£ç ï¼š

```javascript
// æœ‰è¿™æ ·çš„ä¸€æ‰‡é—¨
class WoodenDoor {
  constructor(width, height){
    this.width = width
    this.height = height
  }

  getWidth(){
    return this.width
  }

  getHeight(){
    return this.height
  }
}

// è¿™å°±æ˜¯ä¸€ä¸ªSimple factory
const DoorFactory = {
  makeDoor : (width, height) => new WoodenDoor(width, height)
}

// è°ƒç”¨åç›´æ¥è¿”å›ä¸€ä¸ªå¯¹è±¡äº†
const door = DoorFactory.makeDoor(100, 200)
console.log('Width:', door.getWidth())
console.log('Height:', door.getHeight())
```

<Br/>

é—®é¢˜èƒŒæ™¯ï¼šå½“ç”Ÿæˆä¸€ä¸ªå¯¹è±¡çš„é€»è¾‘æ¯”è¾ƒå¤æ‚ï¼Œä¸æ˜¯è¿™é‡Œç›´æ¥ `new XXX`å¯ä»¥è§£å†³ï¼Œé‚£æ„å»ºä¸€å±‚Simple factoryï¼Œä½œä¸ºä½¿ç”¨è€…å’Œç±»çš„æ¡¥æ¢ï¼Œå°è£…å¤„ç†é€»è¾‘

> When creating an object is not just a few assignments and involves some logic, it makes sense to put it in a dedicated factory instead of repeating the same code everywhere.

<Br/>

### Factory Method

è§£é‡Šï¼šçˆ¶ç±»çš„æ„å»ºé€»è¾‘ä¸­é¢„ç•™äº†ä¸€ä¸ªfactory methodï¼Œå­ç±»é€šè¿‡å®šä¹‰è¿™ä¸ªfactory methodçš„å†…å®¹ï¼Œæ³¨å…¥åˆå§‹åŒ–é€»è¾‘

> It provides a way to delegate the instantiation logic to child classes.

<Br/>

JavaScriptä»£ç ï¼šæ‹›è˜çš„æ•…äº‹

```javascript
// çˆ¶ç±»
class HiringManager {
    takeInterview() {
        const interviewer = this.makeInterviewer()	//makeInterviewerå°±æ˜¯é¢„ç•™çš„factory method
        interviewer.askQuestions()
    }
}

class Developer {
  askQuestions() {
    console.log('Asking about design patterns!')
  }
}

class CommunityExecutive {
  askQuestions() {
    console.log('Asking about community building')
  }
}

// å­ç±»1
class DevelopmentManager extends HiringManager {
    makeInterviewer() {
        return new Developer()
    }
}

// å­ç±»2
class MarketingManager extends HiringManager {
    makeInterviewer() {
        return new CommunityExecutive()
    }
}

// è°ƒç”¨ä¸€ä¸‹
const devManager = new DevelopmentManager()
devManager.takeInterview() 

const marketingManager = new MarketingManager()
marketingManager.takeInterview() 
```

<Br/>

å…·ä½“çš„é—®é¢˜èƒŒæ™¯ï¼šä¸æ˜¯ç‰¹åˆ«ç†è§£ï¼Œå¤§æ¦‚å°±æ˜¯è¯´åœ¨çˆ¶ç±»å®šä¹‰äº†é€šç”¨çš„æ–¹æ³•ï¼Œè€Œéœ€è¦å­ç±»å»åŠ¨æ€æ³¨å…¥é€»è¾‘

> Useful when there is some generic processing in a class but the required sub-class is dynamically decided at runtime. Or putting it in other words, when the client doesn't know what exact sub-class it might need.



<Br/>

### Abstract Factory

è§£é‡Šï¼šæŠŠç›¸å…³çš„factoryèšåˆ°ä¸€èµ·äº†ï¼Œæ‰€ä»¥æ˜¯factoryçš„factory

> A factory of factories a factory that groups the individual but related/dependent factories together without specifying their concrete classes.

<Br/>

JavaScriptä»£ç ï¼š

```javascript
class WoodenDoor {
    getDescription() {
        console.log('I am a wooden door')
    }
}

class IronDoor {
    getDescription() {
        console.log('I am an iron door')
    }
}

class Welder {
    getDescription() {
        console.log('I can only fit iron doors')
    }
}

class Carpenter {
    getDescription() {
        console.log('I can only fit wooden doors')
    }
}

// Wooden factory to return carpenter and wooden door
class WoodenDoorFactory {
    makeDoor(){
        return new WoodenDoor()
    }

    makeFittingExpert() {
        return new Carpenter()
    }
}

// Iron door factory to get iron door and the relevant fitting expert
class IronDoorFactory {
    makeDoor(){
        return new IronDoor()
    }

    makeFittingExpert() {
        return new Welder()
    }
}
```

<Br/>

## Behavioral Design Patterns

è§’è‰²ä»¬çš„èŒè´£ã€è§’è‰²é—´çš„é€šè®¯ï¼Œè¿™äº›å…±åŒå®šä¹‰äº†è¡Œä¸ºï¼š

> In software engineering, behavioral design patterns are design patterns that identify common communication patterns between objects and realize these patterns. By doing so, these patterns increase flexibility in carrying out this communication.

<Br/>

### **ğŸ˜**Observer

Rxçš„å¥½æœ‹å‹ï¼

<Br/>

è§£é‡Šï¼šä¸€ä¸ªå¯¹è±¡çš„çŠ¶æ€å‘ç”Ÿå˜åŒ–æ—¶ï¼Œæ‰€ä»¥ä¾èµ–è¿™ä¸ªå¯¹è±¡çš„éƒ½ä¼šå¾—åˆ°é€šçŸ¥ã€‚è¿™å‰ä¸€ä¸ªå¯¹è±¡æœ‰ä¸€ä¸ªåå­—å«åš `Subject`ï¼Œä¾èµ–è¿™ä¸ªå¯¹è±¡çš„å°±å«åš`Observers`

> å®é™…DEMOè§£é‡Šï¼š
>
> > A good example would be the job seekers where they subscribe to some job posting site and they are notified whenever there is a matching job opportunity.
>
> ç®€å•è§£é‡Šï¼š
>
> > Defines a dependency between objects so that whenever an object changes its state, all its dependents are notified.
>
> Wikipediaï¼š
>
> > The observer pattern is a software design pattern in which an object, called the subject, maintains a list of its dependents, called observers, and notifies them automatically of any state changes, usually by calling one of their methods.

<Br/>

javascriptä»£ç ï¼š

```javascript
// Subject
const JobPost = (title) => ({ title });

// Observer
class JobSeeker {
  constructor(name) {
    this._name = name;
  }

  notify(jobPost) {
    console.log(
      this._name,
      jobPost.title
    );
  }
}

// è¿™ä¸ªboardè§’è‰²ï¼Œæ‰¿æ¥äº†é€šè®¯èŒè´£
class JobBoard {
  constructor() {
    this._subscribers = [];
  }

  subscribe(jobSeeker) {
    this._subscribers.push(jobSeeker);	// æ”¶é›†ä¾èµ–
  }

  // Subjectå˜åŒ–çš„æ—¶å€™ï¼Œæ¯ä¸ªobserverçš„æ‰§è¡Œé€»è¾‘
  addJob(jobPosting) {
    this._subscribers.forEach((subscriber) => {
      subscriber.notify(jobPosting);
    });
  }
}

const jonDoe = new JobSeeker("John Doe");
const janeDoe = new JobSeeker("Jane Doe");
const kaneDoe = new JobSeeker("Kane Doe");

const jobBoard = new JobBoard();
jobBoard.subscribe(jonDoe);
jobBoard.subscribe(janeDoe);

jobBoard.addJob(JobPost("Software Engineer"));
```

<Br/>

### â¿ Iterator

è¿­ä»£å™¨

æœ‰è¿™æ ·ä¸€ä¸ªè¿­ä»£å™¨ï¼Œå¯ä»¥éå†ä¸€ä¸ªå®¹å™¨ï¼Œè·å–å®¹å™¨çš„æ¯ä¸ªå…ƒç´ ...

> ç®€å•è§£é‡Šï¼š
>
> > It presents a way to access the elements of an object without exposing the underlying presentation.
>
> Wikipediaï¼š
>
> > In object-oriented programming, the iterator pattern is a design pattern in which an iterator is used to traverse a container and access the container's elements. The iterator pattern decouples algorithms from containers; in some cases, algorithms are necessarily container-specific and thus cannot be decoupled.