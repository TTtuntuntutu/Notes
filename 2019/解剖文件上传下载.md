## 上传

（以element-ui 2.13.0的upload组件来分析）

起作用的DOM元素，它是`<input type="file">`：

```jsx
<input class="el-upload__input" type="file" ref="input" name={name} on-change={handleChange} multiple={multiple} accept={accept}></input>
```



### 打开选择文件界面

挂在`input`父元素的点击事件处理，调用`<input type="file">`的`click`方法，打开选择文件界面：

```javascript
handleClick() {
  if (!this.disabled) {
    this.$refs.input.value = null;
    this.$refs.input.click();
  }
}
```



### 获取选择文件的信息

挂在`input`元素的change事件处理：

```javascript
handleChange(ev) {
  const files = ev.target.files;

  if (!files) return;
  this.uploadFiles(files);
}
```



文件的信息在`HTMLInputElement.files`，属性值是一个 [`FileList`](https://developer.mozilla.org/en-US/docs/Web/API/FileList) ，是一个[`File`](https://developer.mozilla.org/en-US/docs/Web/API/File)对象的集合。

### 上传文件

#### 壳子

upload组件上传分自动上传和手动上传，方法是`post`，把上传配置信息和文件信息组合起来：

```javascript
post(rawFile) {
  const { uid } = rawFile;
  const options = {
    headers: this.headers,
    withCredentials: this.withCredentials,
    file: rawFile,
    data: this.data,
    filename: this.name,
    action: this.action,
    onProgress: e => {
      this.onProgress(e, rawFile);
    },
    onSuccess: res => {
      this.onSuccess(res, rawFile);
      delete this.reqs[uid];
    },
    onError: err => {
      this.onError(err, rawFile);
      delete this.reqs[uid];
    }
  };
  const req = this.httpRequest(options);
  this.reqs[uid] = req;
  if (req && req.then) {
    req.then(options.onSuccess, options.onError);
  }
}
```

其中`httpRequest`是一个可配置内容，默认是`ajax`

#### 干活

干活的当然是`ajax`，关键就在这个`FormData`了：

```javascript
const formData = new FormData();

if (option.data) {
  //附带的额外参数
  Object.keys(option.data).forEach(key => {
    formData.append(key, option.data[key]);
  });
}

//文件信息
formData.append(option.filename, option.file, option.file.name);

xhr.send(formData);
```



`FormData`是什么？

> The **`FormData`** interface provides a way to  easily construct a set of key/value pairs representing form fields and  their values, which can then be easily sent using the [`XMLHttpRequest.send()`](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/send) method. It uses the same format a form would use if the encoding type were set to `"multipart/form-data"`.



### OSS?

对象存储服务（Object Storage Service，简称 OSS），用来存储上传的文件。

在upload这里使用，得提前拿到一些配置数据（摘了crm里面的）：

```javascript
getOssSign(file) {
  return new Promise((resolve, reject) => {
    let config = {
      fileName: this.addTampToFilename(file.name),
      type: this.type,
    }

    getUploadSignGaea(config)
      .then(res => {
        let {
          bucket,
          cloudKey,
          host,
          cosEnable,
          uploadByPostSignDO: {
            policy,
            ossAccessId,
            sign,
            qKeyTime,
            qSignAlgorithm,
          },
        } = res
        this.data = cosEnable
          ? {
              'q-ak': ossAccessId,
              'q-signature': sign,
              key: cloudKey,
              policy: policy,
              'q-key-time': qKeyTime,
              'q-sign-algorithm': qSignAlgorithm,
            }
          : {
              key: cloudKey,
              OSSAccessKeyId: ossAccessId,
              policy,
              Signature: sign,
            }
        this.action = host
        file.ossUrl = this.fullUrl ? `${host}/${cloudKey}` : cloudKey

        setTimeout(_ => {
          resolve()
        }, 0)
      })
      .catch(() => reject())
  })
},
```



简单分析一下：

1. 后端提供接口获取oss必要配置数据（这里是`getUploadSignGaea`）：配置参数参照这里，一个唯一的文件名（`uuid`）+一个oss类型（私有还是公有）
2. 配置数据有哪些？`this.data`，用在upload组件的`data`属性，上传时附带的额外参数；`this.action`，用在upload组件的`action`属性，上传的地址；`file.ossUrl` 文件的 oss域名
3. 这个`getOssSign`函数逻辑放在upload组件的`before-upload`钩子去执行



### 其他

#### 文件类型的限制

通过`input`的`accept`属性做的**前端限制**：

```html
<form method="post" enctype="multipart/form-data">
  <div>
    <label for="profile_pic">Choose file to upload</label>
    <input type="file" id="profile_pic" name="profile_pic"
          accept=".jpg, .jpeg, .png">
  </div>
  <div>
    <button>Submit</button>
  </div>
</form>
```

是不安全的，用户完全可以打开开发者工具，去掉`accept`的限制。

所以需要服务端做类型的判断，或者在组件提交前在代码里做判断（upload组件做法是提供钩子，用户可在钩子内做判断）



#### `input`的`value`属性

挂在这样的`input`上的`value`属性，指向选择文件的path（如果是多选，指向第一个选择的文件），带有`C:\fakepath\`前缀，手动改这个值是无效的，比如

```javascript
const input = document.querySelector("input[type=file]");
input.value = "foo";
```



## 下载

`a`标签的`download`属性

[Download file in JavaScript— From ByteA](https://medium.com/@riccardopolacci/download-file-in-javascript-from-bytea-6a0c5bb3bbdb)

[JavaScript文件](https://wonderlust91.github.io/javascript文件下载的三种方式/)

[mdn-a标签](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a)



## 其他

### uuid

在去OSS“开房”的时候有这样的一段代码：

```javascript
addTampToFilename(filename) {
  const lastIdx = filename.lastIndexOf('.')
  const uuid = uuidv5(filename + new Date(), uuidv5.URL)
  let suffix = ''
  if (lastIdx > -1) {
    const len = filename.length
    suffix = filename.substring(lastIdx, len)
  }
  return uuid + suffix
}
```



这里的需求是返回一个唯一的文件名，用了[uuid(**U**niversally **U**nique **Id**entifier)：通用唯一识别码](https://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E5%94%AF%E4%B8%80%E8%AF%86%E5%88%AB%E7%A0%81#%E7%89%88%E6%9C%AC)：

- 这个解释[Generating v5 UUID. What is name and namespace?](https://stackoverflow.com/questions/10867405/generating-v5-uuid-what-is-name-and-namespace) 非常好
- 用到了[npm-uuid](https://www.npmjs.com/package/uuid) v5



### 上传指定 excel 文件问题

这样的代码指定excel的MIME types，以支持选择excel上传：

```html
  <input type="file"
    accept="application/vnd.ms-excel,application/vnd.openxmlformats-officedocument.spreadsheetml.sheet">
```



但是在 Chrome 80.0.3987.122 版本下 `.xls` 后缀的文件没法选择。通过`change`事情获取选择`.xls`文件时的文件信息：

```html
<input type="file" id="file">
<script>
  const item = document.getElementById('file')
  item.addEventListener('change', function (e) {
    console.log(e.target.files)
  })
</script>
```

打印出来的`File`：

```javascript
{
  name: "11.xls"
  lastModified: 1582621818660
  lastModifiedDate: Tue Feb 25 2020 17:10:18 GMT+0800 (中国标准时间) {}
  webkitRelativePath: ""
  size: 25088
  type: ""
}
```

`File.type`：返回文件的 [多用途互联网邮件扩展类型（MIME Type）](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types)

在这里`File.type`为空。



作为对比，查看一下同样代码，在支持选择`.xls`后缀文件的Safari打印出来的`File`：

```javascript
{
  lastModified: 1582621818000
  name: "11.xls"
  size: 25088
  type: "application/vnd.ms-excel"
  webkitRelativePath: ""
}
```



这就解释了为什么在指定`accept`值后，Safari支持选择`.xls`后缀文件，而Chrome这个版本是不可以的。文件的`type`属性只有在`accpet`值中，才允许被选择。

## 参考链接

[Uploading Files With VueJS and Axios ](https://serversideup.net/uploading-files-vuejs-axios/) ：讲了完整的选择文件+文件上传

[mdn-Using files from web applications](https://developer.mozilla.org/en-US/docs/Web/API/File/Using_files_from_web_applications) ：讲了完整的选择文件+文件上传

[mdn - <input type="file">](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file)

[mdn-FileList](https://developer.mozilla.org/en-US/docs/Web/API/FileList)

[mdn-File](https://developer.mozilla.org/en-US/docs/Web/API/File)

[mdn-FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData)